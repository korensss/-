<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>×—×•×˜×‘ ×”×¢×•×¤×•×ª</title>
  <style>
    :root{
      --bg:#0c1210;
      --panel:rgba(0,0,0,.55);
      --text:#e8f3ee;
      --muted:#b7c8c0;
      --accent:#7ee2b8;
      --danger:#ff4d6d;
    }
    *{box-sizing:border-box; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    body{margin:0; background:linear-gradient(180deg,#030605,#0a1411 40%,#050807); color:var(--text); overflow:hidden;}

    #wrap{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr;}

    header{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 14px;
      background:linear-gradient(180deg, rgba(0,0,0,.65), rgba(0,0,0,.25));
      border-bottom:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(10px);
    }

    .left, .right{display:flex; align-items:center; gap:10px;}

    .badge{padding:6px 10px; border:1px solid rgba(255,255,255,.12); border-radius:999px; background:rgba(0,0,0,.35); font-weight:600;}
    .badge strong{color:var(--accent)}

    button{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.35);
      color:var(--text);
      border-radius:12px;
      padding:8px 10px;
      font-weight:700;
    }
    button:hover{border-color:rgba(126,226,184,.6)}

    #gameArea{position:relative; width:100%; height:100%;}
    canvas{width:100%; height:100%; display:block; image-rendering:pixelated;}

    #hud{
      position:absolute; left:12px; top:12px;
      background:var(--panel);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:10px 12px;
      width:min(360px, calc(100% - 24px));
      backdrop-filter: blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    #hud h1{margin:0 0 6px; font-size:16px; letter-spacing:.2px;}
    #hud p{margin:0; color:var(--muted); font-size:13px; line-height:1.35}
    .row{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:8px;}
    .bar{height:10px; background:rgba(255,255,255,.10); border-radius:999px; overflow:hidden; flex:1;}
    .fill{height:100%; width:0%; background:linear-gradient(90deg, rgba(126,226,184,.95), rgba(126,226,184,.55));}
    .tiny{font-size:12px; color:var(--muted)}

    #hint{
      position:absolute; right:12px; top:12px;
      background:var(--panel);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:10px 12px;
      width:min(420px, calc(100% - 24px));
      backdrop-filter: blur(10px);
    }
    #hint b{color:var(--accent)}

    #overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:radial-gradient(circle at 50% 45%, rgba(0,0,0,.45), rgba(0,0,0,.85));
      opacity:1;
      transition:opacity .35s ease;
    }
    #overlay.hidden{opacity:0; pointer-events:none;}

    .card{
      width:min(720px, calc(100% - 32px));
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius:22px;
      padding:18px;
      backdrop-filter: blur(14px);
      box-shadow:0 20px 60px rgba(0,0,0,.55);
    }
    .card h2{margin:0 0 8px; font-size:18px}
    .card ul{margin:10px 0 0; padding:0 18px; color:var(--muted);}
    .card li{margin:6px 0}
    .card .actions{display:flex; gap:10px; margin-top:12px; flex-wrap:wrap}

    /* Jumpscare (friendly) */
    #jumpscare{
      position:absolute; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.55);
      z-index:50;
      overflow:hidden;
    }
    #jumpscare.show{display:flex; animation:flash .55s ease-out;}

    #confetti{position:absolute; inset:0; width:100%; height:100%;}

    .jwrap{
      position:relative;
      width:min(560px, 90vw);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      background:rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.12);
      border-radius:22px;
      padding:14px;
      backdrop-filter: blur(10px);
      box-shadow:0 20px 80px rgba(0,0,0,.35);
    }

    #bigiImg{
      width:100%;
      max-width:520px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      image-rendering:auto;
      display:block;
    }

    .jtxt{
      font-weight:900;
      font-size:18px;
      color:var(--text);
      text-align:center;
      padding:8px 10px;
      border-radius:14px;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
    }

    @keyframes flash{
      0%{transform:scale(1); filter:blur(0px)}
      20%{transform:scale(1.02); filter:blur(0px)}
      100%{transform:scale(1); filter:blur(0px)}
    }

    #toast{
      position:absolute;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      background:rgba(0,0,0,.65);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:10px 14px;
      color:var(--muted);
      backdrop-filter: blur(10px);
      display:none;
      z-index:20;
    }
    #toast.show{display:block;}

    kbd{
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.14);
      border-bottom-width:2px;
      padding:2px 6px;
      border-radius:8px;
      color:var(--text);
      font-weight:700;
      font-size:12px;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <header>
      <div class="left">
        <div class="badge">×©×œ×‘: <strong id="stageLbl">1</strong>/7</div>
        <div class="badge">×¢×•×¤×•×ª: <strong id="woodLbl">0</strong></div>
      </div>
      <div class="right">
        <button id="btnRestart" title="×”×ª×—×œ ××—×“×©">×”×ª×—×œ ××—×“×©</button>
        <button id="btnMute" title="×”×©×§×˜/×”×¤×¢×œ ×¡××•× ×“">×¡××•× ×“: ON</button>
      </div>
    </header>

    <div id="gameArea">
      <canvas id="c" tabindex="0"></canvas>

      <div id="hud">
        <h1 id="mission">×—×˜×•×‘ 6 ×¢×•×¤×•×ª ×›×“×™ ×œ×¡×™×™× ××ª ×”×©×œ×‘</h1>
        <p id="flavor">×™×•× ×¨×’×•×¢ ×‘×©×“×”. ××ª×” ×¨×§â€¦ ×—×•×˜×‘ ×¢×•×£.</p>
        <div class="row">
          <div class="bar"><div class="fill" id="prog"></div></div>
          <div class="tiny"><span id="needLbl">0</span>/<span id="goalLbl">0</span></div>
        </div>
      </div>

      <div id="hint">
        <div><b>×©×œ×™×˜×”:</b> ×ª×–×•×–×” ×¢× ×—×¦×™× <kbd>â†‘</kbd><kbd>â†“</kbd><kbd>â†</kbd><kbd>â†’</kbd> â€¢ ××¦×œ××” ×¢× <b>×¢×›×‘×¨</b> (×œ×—×¥ ×¢×œ ×”××¡×š ×›×“×™ ×œ× ×¢×•×œ ×¢×›×‘×¨) â€¢ ×—×¦×™×‘×” ×¢× <kbd>E</kbd> ××• ×§×œ×™×§</div>
        <div style="margin-top:6px; color:var(--muted)">×”×ª×§×¨×‘ ×œ×¢×•×£ ×›×“×™ ×œ×—×˜×•×‘. ×›×›×œ ×©××ª×§×“××™×â€”×”××•×•×™×¨×” ××©×ª× ×”.</div>
      </div>

      <div id="overlay">
        <div class="card">
          <h2>×—×•×˜×‘ ×”×¢×•×¤×•×ª</h2>
          <div style="color:var(--muted); line-height:1.45">
            ××©×—×§ ××™× ×“×™ ×§×¦×¨: ×œ×—×˜×•×‘ ×¢×•×£ ×›×“×™ ×œ×”×ª×§×“× ×‘×™×Ÿ ×©×œ×‘×™×.
            ×‘×©×œ×‘ ××¡×•×™×â€¦ ××©×”×• ×§×•×¤×¥.
          </div>
          <ul>
            <li>××˜×¨×” ×‘×›×œ ×©×œ×‘: ×œ×—×˜×•×‘ ××ª ×›××•×ª ×”×¢×•×¤×•×ª ×”××‘×•×§×©×ª.</li>
            <li>×”×ª×§×¨×‘ ×œ×¢×•×£ ×•×œ×—×¥ <kbd>E</kbd> ××• ×§×œ×™×§ ×›×“×™ ×œ×—×˜×•×‘.</li>
            <li>×˜×™×¤: ×©×—×§ ×¢× ××•×–× ×™×•×ª ğŸ˜‰</li>
          </ul>
          <div class="actions">
            <button id="btnStart">×©×—×§</button>
            
          </div>
        </div>
      </div>

      <div id="jumpscare" aria-hidden="true">
        <canvas id="confetti"></canvas>
        <div class="jwrap">
          <img id="bigiImg" alt="××–×œ ×˜×•×‘ ×‘×™×’×™" src="bigi.png" />
          <div class="jtxt">××–×œ ×˜×•×‘ ×‘×™×’×™ ××•×”×‘ ğŸ’š</div>
        </div>
      </div>

      <div id="toast"> </div>
    </div>
  </div>

<script>
(() => {
  // ===== Pixel-3D (Raycaster) â€“ Undertale/Deltarune-ish inspiration =====
  // Note: "Undertale/Deltarune style" here means chunky pixels + limited palette + snappy FX,
  // not copying any specific art assets.

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const stageLbl = document.getElementById('stageLbl');
  const woodLbl = document.getElementById('woodLbl');
  const mission = document.getElementById('mission');
  const flavor = document.getElementById('flavor');
  const prog = document.getElementById('prog');
  const needLbl = document.getElementById('needLbl');
  const goalLbl = document.getElementById('goalLbl');

  const overlay = document.getElementById('overlay');
  const btnStart = document.getElementById('btnStart');
    const btnRestart = document.getElementById('btnRestart');
  const btnMute = document.getElementById('btnMute');
  const jumpscare = document.getElementById('jumpscare');
  const confettiCanvas = document.getElementById('confetti');
  const bigiImg = document.getElementById('bigiImg');
  const toast = document.getElementById('toast');

  // --- Audio (WebAudio) ---
  let audioCtx = null;
  let muted = false;
  function ensureAudio(){
    if (muted) return null;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    return audioCtx;
  }
  function beep({freq=440, dur=0.08, type='sine', gain=0.03}={}){
    const ac = ensureAudio();
    if (!ac) return;
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(ac.destination);
    o.start(); o.stop(ac.currentTime + dur);
  }
  function creepyChord(){
    beep({freq:196, dur:0.12, gain:0.018, type:'triangle'});
    beep({freq:207.65, dur:0.14, gain:0.016, type:'triangle'});
    beep({freq:233.08, dur:0.10, gain:0.014, type:'triangle'});
  }

  // --- Low-res buffer for pixel look ---
  const buf = document.createElement('canvas');
  const bctx = buf.getContext('2d');

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(canvas.clientWidth  * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);

    // internal resolution
    const targetH = 200;
    const aspect = canvas.width / canvas.height;
    buf.height = targetH;
    buf.width  = Math.max(240, Math.floor(targetH * aspect));

    ctx.imageSmoothingEnabled = false;
    bctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', resize);

  // --- Stages ---
  const STAGES = [
    {goal:6,  title:'×—×˜×•×‘ 6 ×¢×•×¤×•×ª ×›×“×™ ×œ×¡×™×™× ××ª ×”×©×œ×‘',  text:'×™×•× ×¨×’×•×¢ ×‘×©×“×”. ××ª×” ×¨×§â€¦ ×—×•×˜×‘ ×¢×•×£.',                              mood:0},
    {goal:7,  title:'×—×˜×•×‘ 7 ×¢×•×¤×•×ª',                 text:'×”×©××© ×™×•×¨×“×ª. ×¤×ª××•× ×©×•××¢×™× ××©×”×• ×¨×—×•×§â€¦',                            mood:1},
    {goal:8,  title:'×—×˜×•×‘ 8 ×¢×•×¤×•×ª',                 text:'×œ×™×œ×” ×¨××©×•×Ÿ. ××ª×” ××¨×’×™×© ×©××¡×ª×›×œ×™× ×¢×œ×™×š.',                           mood:2},
    {goal:9,  title:'×—×˜×•×‘ 9 ×¢×•×¤×•×ª',                 text:'×”×›×œ ××ª×—×™×œ ×œ×”×—×©×™×š. ×›×œ ×¦×¢×“ × ×©××¢ ×—×–×§ ×™×•×ª×¨.',                         mood:3},
    {goal:10, title:'×—×˜×•×‘ 10 ×¢×•×¤×•×ª',                text:'×”××•×•×™×¨ ×›×‘×“. ×¤×¢×™××•×ª ×œ×‘â€¦ ×§×¨×•×‘×•×ª.',                                  mood:4},
    {goal:6,  title:'×—×˜×•×‘ 6 ×¢×•×¤×•×ª',                 text:'×–×” ×”×¤×™×§. ×—×•×©×š. × ×©×™××”. ×•××ª×” ×××©×™×šâ€¦',                               mood:5},
    {goal:1,  title:'×—×˜×•×‘ ×¢×•×“ ×¢×•×£ ××—×“ ×‘×œ×‘×“',        text:'×•××–â€”×”×›×œ × ×”×™×” ×˜×•×‘.',                                                mood:6},
  ];

  // --- Map / World (grid for raycasting) ---
  const MAP_W = 28;
  const MAP_H = 28;
  let map = new Array(MAP_W*MAP_H).fill(0);

  // tile ids: 0 empty, 1 wall/rock, 2 special dark rock
  function idx(x,y){return y*MAP_W+x;}
  function inb(x,y){return x>=0 && y>=0 && x<MAP_W && y<MAP_H;}
  function cell(x,y){ if(!inb(x,y)) return 1; return map[idx(x,y)]|0; }

  function generateMap(mood){
    map.fill(0);

    // borders (watermelon walls)
    for (let x=0;x<MAP_W;x++){ map[idx(x,0)]=1; map[idx(x,MAP_H-1)]=1; }
    for (let y=0;y<MAP_H;y++){ map[idx(0,y)]=1; map[idx(MAP_W-1,y)]=1; }

    // random walls
    const rocks = 40 + mood*10;
    for (let i=0;i<rocks;i++){
      const x = 2 + (Math.random()*(MAP_W-4))|0;
      const y = 2 + (Math.random()*(MAP_H-4))|0;
      if ((Math.abs(x-14)+Math.abs(y-14)) < 5) continue;
      map[idx(x,y)] = 1;
    }

    // 1 out of ~80 wall tiles gets graffiti (tile id 3)
    // (we select from existing wall cells so it actually appears)
    let walls = 0;
    for (let y=1;y<MAP_H-1;y++){
      for (let x=1;x<MAP_W-1;x++){
        if (map[idx(x,y)] === 1) walls++;
      }
    }
    const graffitiCount = Math.max(1, Math.round(walls / 80));
    let placed = 0;
    let guard = 0;
    while (placed < graffitiCount && guard++ < 5000){
      const x = 1 + (Math.random()*(MAP_W-2))|0;
      const y = 1 + (Math.random()*(MAP_H-2))|0;
      if (map[idx(x,y)] !== 1) continue;
      map[idx(x,y)] = 3;
      placed++;
    }
  }

  // --- Entities (trees) ---
  let trees = [];
  function spawnTrees(stage){
    trees = [];
    const n = Math.min(18 + stage*2, 30);
    for (let i=0;i<n;i++){
      let tries = 0;
      while (tries++ < 200){
        const x = 2 + Math.random()*(MAP_W-4);
        const y = 2 + Math.random()*(MAP_H-4);
        if (cell(x|0, y|0) !== 0) continue;
        const dx = x-14, dy = y-14;
        if (Math.hypot(dx,dy) < 3.5) continue;
        trees.push({x, y, hp:3, alive:true});
        break;
      }
    }
  }

  // --- Player (first person) ---
  const player = {
    x: 14.5,
    y: 14.5,
    a: 0,        // angle
    fov: Math.PI/3,
    speed: 2.5,
    rot: 2.2,
  };

  // --- State ---
  let stage = 0;
  let stageWood = 0;
  let totalWood = 0;
  let running = false;
  let flicker = 0;

  // Flying buckets (fast, bird-like)
  const flyers = [];
  let flySpawn = 0;

  // ambience timing
  let heartT = 0;
  let stepT = 0;
  let breathT = 0;

  function stageIntensity(){
    // 0..1 ramp to stage 6 peak (index 5)
    return Math.max(0, Math.min(1, stage / 5));
  }

  function heartbeat(level){
    // soft double-thump
    const base = 60 + level*45; // bpm-ish
    const interval = 60 / base;
    // thump 1
    beep({freq: 90 - level*10, dur:0.05, gain:0.010 + level*0.020, type:'sine'});
    beep({freq: 55 - level*6,  dur:0.06, gain:0.008 + level*0.016, type:'triangle'});
    // thump 2 (slightly after)
    setTimeout(()=>{
      beep({freq: 100 - level*10, dur:0.04, gain:0.008 + level*0.018, type:'sine'});
      beep({freq: 60 - level*6,  dur:0.05, gain:0.006 + level*0.014, type:'triangle'});
    }, 120);
    return interval;
  }

  function softStep(level){
    const ac = ensureAudio();
    if (!ac) return;
    const dur = 0.03;
    const bufferSize = Math.floor(ac.sampleRate * dur);
    const buffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2 - 1) * 0.7;
    const src = ac.createBufferSource();
    src.buffer = buffer;
    const f = ac.createBiquadFilter();
    f.type = 'lowpass';
    f.frequency.value = 380 + level*120;
    const g = ac.createGain();
    g.gain.value = 0.010 + level*0.018;
    src.connect(f); f.connect(g); g.connect(ac.destination);
    src.start();
  }

  function softBreath(level){
    const ac = ensureAudio();
    if (!ac) return;
    const dur = 0.18;
    const bufferSize = Math.floor(ac.sampleRate * dur);
    const buffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2 - 1);
    const src = ac.createBufferSource();
    src.buffer = buffer;
    const f = ac.createBiquadFilter();
    f.type = 'bandpass';
    f.frequency.value = 900;
    f.Q.value = 0.6;
    const g = ac.createGain();
    g.gain.value = 0.004 + level*0.010;
    src.connect(f); f.connect(g); g.connect(ac.destination);
    src.start();
  }

  // confetti
  function runConfetti(ms=900){
    const c = confettiCanvas;
    const r = c.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    c.width = Math.floor(r.width * dpr);
    c.height = Math.floor(r.height * dpr);
    const g = c.getContext('2d');
    g.imageSmoothingEnabled = false;

    const parts = [];
    const N = 120;
    for (let i=0;i<N;i++){
      parts.push({
        x: Math.random()*c.width,
        y: -Math.random()*c.height*0.3,
        vx: (Math.random()*2-1) * 120 * dpr,
        vy: (60 + Math.random()*220) * dpr,
        r: 2 + (Math.random()*4)|0,
        t: Math.random()*Math.PI*2,
        vt: (Math.random()*2-1) * 6,
      });
    }

    const t0 = performance.now();
    function frame(now){
      const dt = Math.min(0.05, (now - (frame._p||now))/1000);
      frame._p = now;
      const elapsed = now - t0;
      g.clearRect(0,0,c.width,c.height);

      for (const p of parts){
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.t += p.vt * dt;
        if (p.y > c.height + 20*dpr) p.y = -10*dpr;
        if (p.x < -20*dpr) p.x = c.width + 20*dpr;
        if (p.x > c.width + 20*dpr) p.x = -20*dpr;

        const s = Math.sin(p.t);
        g.fillStyle = (s>0.5) ? 'rgba(255,74,106,0.9)' : (s<-0.5) ? 'rgba(43,255,122,0.9)' : 'rgba(255,255,255,0.9)';
        g.fillRect(p.x, p.y, p.r, p.r);
      }

      if (elapsed < ms) requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  }

  // --- Controls ---
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (!running) return;
    const k = e.key.toLowerCase();
    if (['e','arrowup','arrowdown','arrowleft','arrowright'].includes(k)) e.preventDefault();
    // keep only arrows + E for gameplay
    if (k === 'e' || k.startsWith('arrow')) keys.add(k);
    if (k === 'e') tryChop();
  });
  window.addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    if (k === 'e' || k.startsWith('arrow')) keys.delete(k);
  });
  // Click: chop + (try) pointer-lock for mouse look
  canvas.addEventListener('mousedown', (e) => {
    if (!running) return;
    canvas.focus();
    tryChop();

    // try pointer lock (best experience)
    if (document.pointerLockElement !== canvas) {
      try { canvas.requestPointerLock(); } catch {}
    }

    // fallback: click+drag mouse-look (if pointer lock is blocked in this environment)
    mouse.dragging = true;
    mouse.lastX = e.clientX;
  });
  window.addEventListener('mouseup', () => { mouse.dragging = false; });

  // Mouse look (pointer lock + fallback drag)
  const mouse = {locked:false, dragging:false, lastX:0, sens:0.0024};
  document.addEventListener('pointerlockchange', () => {
    mouse.locked = (document.pointerLockElement === canvas);
    if (mouse.locked) {
      showToast('×”×¢×›×‘×¨ × × ×¢×œ â€“ ×”×–×– ×›×“×™ ×œ×”×¡×ª×•×‘×‘ (ESC ×œ×©×—×¨×•×¨)', 1600);
      mouse.dragging = false;
    }
  });
  document.addEventListener('pointerlockerror', () => {
    // some previews/iframes block pointer lock
    showToast('× ×¢×™×œ×ª ×¢×›×‘×¨ ×—×¡×•××” ×›××Ÿ â€” ×”×¡×ª×•×‘×‘ ×¢× ×§×œ×™×§+×’×¨×™×¨×”', 2000);
  });
  document.addEventListener('mousemove', (e) => {
    if (!running) return;
    if (mouse.locked) {
      player.a += e.movementX * mouse.sens;
      return;
    }
    if (mouse.dragging) {
      const dx = (e.clientX - mouse.lastX);
      mouse.lastX = e.clientX;
      player.a += dx * mouse.sens;
    }
  });

  function showToast(msg, ms=1400){
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove('show'), ms);
  }

  function setStage(n){
    stage = Math.max(0, Math.min(STAGES.length-1, n));
    stageWood = 0;
    const s = STAGES[stage];
    stageLbl.textContent = String(stage+1);
    mission.textContent = s.title;
    flavor.textContent = s.text;
    goalLbl.textContent = String(s.goal);
    needLbl.textContent = String(stageWood);
    prog.style.width = '0%';

    // regenerate
    generateMap(s.mood);
    spawnTrees(stage);

    // reposition & angle
    player.x = 14.5;
    player.y = 14.5;
    player.a = (Math.random()*Math.PI*2);

    // cues
    if (stage === 1) beep({freq:330, dur:0.08, gain:0.02, type:'sine'});
    if (stage === 2) beep({freq:220, dur:0.08, gain:0.02, type:'triangle'});
    if (stage === 3) creepyChord();
    if (stage === 4) creepyChord();
    if (stage === 5) beep({freq:110, dur:0.12, gain:0.025, type:'sawtooth'});
  }

  function nextStage(){
    if (stage >= STAGES.length-1){
      win();
      return;
    }
    setStage(stage+1);
    if (stage === 6) showToast('â€¦×¢×•×“ ×¦×¢×“ ××—×“', 1600);
  }

  function win(){
    running = false;
    overlay.classList.remove('hidden');
    overlay.querySelector('h2').textContent = '×¡×™×•×';
    overlay.querySelector('div').innerHTML = '<div style="color:var(--muted); line-height:1.55">×¡×™×™××ª ×œ×—×˜×•×‘ ×¢×•×£.<br>×”×—×•×©×š × ×¢×œ×â€¦ ×•×”×›×œ ×‘×¡×“×¨.<br><b style="color:var(--accent)">××–×œ ×˜×•×‘ ×‘×™×’×™ ğŸ’š</b></div>';
    overlay.querySelector('ul').innerHTML = '<li>×¨×•×¦×” ×¢×•×“? ××¤×©×¨ ×œ×”×•×¡×™×£ ×¨×“×™×¤×•×ª, ××©×™××•×ª, ×•×¡×•×¤×™× ×©×•× ×™×.</li>';
    overlay.querySelector('.actions').innerHTML = '<button id="btnAgain">×©×—×§ ×©×•×‘</button>';
    document.getElementById('btnAgain').onclick = () => location.reload();
  }

  // --- Chopping ---
  function nearestTree(){
    let best=null, bestD=1e9;
    for (const t of trees){
      if (!t.alive) continue;
      const d = Math.hypot(t.x - player.x, t.y - player.y);
      if (d < bestD){ bestD=d; best=t; }
    }
    return {tree:best, d:bestD};
  }

  function microScare(){
    flicker = 0.22;
    creepyChord();
    showToast('â€¦×¨××™×ª ××ª ×–×”?', 1200);
  }

  function doJumpscare(){
    if (!running) return;
    if (jumpscare.classList.contains('show')) return;

    // friendly confetti + photo (not loud)
    jumpscare.classList.add('show');

    // gentle "party pop" (soft)
    beep({freq: 740, dur:0.05, gain:0.012, type:'sine'});
    beep({freq: 520, dur:0.08, gain:0.010, type:'triangle'});

    runConfetti(900);

    setTimeout(()=>{
      jumpscare.classList.remove('show');
    }, 1200);
  }

  function tryChop(){
    const {tree, d} = nearestTree();
    if (!tree) return;
    if (d > 1.6){
      beep({freq:210, dur:0.05, gain:0.012, type:'sine'});
      showToast('×ª×ª×§×¨×‘ ×œ×¢×•×£ ×›×“×™ ×œ×—×˜×•×‘');
      return;
    }

    tree.hp -= 1;
    // chop sound
    beep({freq: 260 + Math.random()*40, dur:0.06, gain:0.02, type:'triangle'});
    beep({freq: 140 + Math.random()*25, dur:0.08, gain:0.015, type:'sine'});

    const mood = STAGES[stage].mood;
    if (stage >= 2 && Math.random() < 0.12){
      // distant meow-ish
      beep({freq: 740 + Math.random()*120, dur:0.03, gain:0.008, type:'sine'});
      beep({freq: 420 + Math.random()*80, dur:0.06, gain:0.010, type:'sine'});
    }

    if (tree.hp <= 0){
      tree.alive = false;
      stageWood += 1;
      totalWood += 1;
      woodLbl.textContent = String(totalWood);
      needLbl.textContent = String(stageWood);
      const goal = STAGES[stage].goal;
      prog.style.width = (Math.min(1, stageWood/goal)*100).toFixed(0) + '%';

      if (stage === 4 && stageWood === Math.max(3, (goal*0.5)|0)) microScare();

      // stage 6 (index 5) full jumpscare
      if (stage === 5 && stageWood === 3) doJumpscare();

      if (stageWood >= goal) nextStage();
    }
  }

  // --- Movement / Collision ---
  function isBlocked(nx, ny){
    return cell(nx|0, ny|0) !== 0;
  }
  function move(dt){
    const mood = STAGES[stage].mood;
    const sp = player.speed * (1 - Math.min(0.10, mood*0.01));

    let fwd = 0, str = 0;
    // ONLY arrows move
    if (keys.has('arrowup')) fwd += 1;
    if (keys.has('arrowdown')) fwd -= 1;
    if (keys.has('arrowleft')) str -= 1;
    if (keys.has('arrowright')) str += 1;

    // camera rotation comes from mouse (pointer lock), not keys

    const ca = Math.cos(player.a), sa = Math.sin(player.a);
    const dx = (ca * fwd + -sa * str) * sp * dt;
    const dy = (sa * fwd +  ca * str) * sp * dt;

    let nx = player.x + dx;
    let ny = player.y + dy;

    // simple collision: separate axes
    if (!isBlocked(nx, player.y)) player.x = nx;
    if (!isBlocked(player.x, ny)) player.y = ny;
  }

  // --- Raycasting render ---
  const PALETTE = {
    // bright silly world
    skyTop: '#66c7ff',
    skyBot: '#1c6cff',
    grassTop: '#2bff7a',
    grassBot: '#0aa84a',

    // watermelon wall (rind + flesh)
    wmRind1: '#1e7a3e',
    wmRind2: '#14552b',
    wmFlesh1: '#ff4a6a',
    wmFlesh2: '#d92b4e',
    seed: '#1a1a1a',

    fog: 'rgba(0,0,0,0.18)',
    accent: '#7ee2b8',
    danger: '#ff4d6d'
  };

  function castRay(rx, ry, ra){
    // DDA
    let mapX = rx|0, mapY = ry|0;
    const rayDirX = Math.cos(ra);
    const rayDirY = Math.sin(ra);

    const deltaDistX = Math.abs(1 / (rayDirX || 1e-9));
    const deltaDistY = Math.abs(1 / (rayDirY || 1e-9));

    let stepX, stepY;
    let sideDistX, sideDistY;

    if (rayDirX < 0) { stepX = -1; sideDistX = (rx - mapX) * deltaDistX; }
    else { stepX = 1; sideDistX = (mapX + 1.0 - rx) * deltaDistX; }

    if (rayDirY < 0) { stepY = -1; sideDistY = (ry - mapY) * deltaDistY; }
    else { stepY = 1; sideDistY = (mapY + 1.0 - ry) * deltaDistY; }

    let hit = 0;
    let side = 0;
    let tile = 1;
    for (let i=0;i<80;i++){
      if (sideDistX < sideDistY){
        sideDistX += deltaDistX;
        mapX += stepX;
        side = 0;
      } else {
        sideDistY += deltaDistY;
        mapY += stepY;
        side = 1;
      }
      tile = cell(mapX, mapY);
      if (tile !== 0){ hit = 1; break; }
    }

    let perpWallDist;
    if (side === 0) perpWallDist = (mapX - rx + (1 - stepX) / 2) / (rayDirX || 1e-9);
    else perpWallDist = (mapY - ry + (1 - stepY) / 2) / (rayDirY || 1e-9);

    perpWallDist = Math.max(0.0001, perpWallDist);
    return {dist: perpWallDist, side, tile};
  }

  // "tree" sprite becomes FRIED CHICKEN (drumstick) sitting on the ground
  const chickenSprite = (() => {
    const s = document.createElement('canvas');
    s.width = 28; s.height = 28;
    const g = s.getContext('2d');
    g.imageSmoothingEnabled = false;

    // outline
    g.fillStyle = '#0a0a0a';
    g.fillRect(6,8,18,16);

    // meat
    g.fillStyle = '#f5a623';
    g.fillRect(8,10,14,12);
    g.fillStyle = '#d98212';
    g.fillRect(14,12,8,10);

    // crispy bits
    g.fillStyle = '#ffcf5a';
    g.fillRect(9,11,3,2);
    g.fillRect(11,14,2,2);
    g.fillRect(10,18,3,2);

    // bone
    g.fillStyle = '#f2f2f2';
    g.fillRect(5,15,4,4);
    g.fillRect(4,14,2,2);
    g.fillRect(4,19,2,2);

    // thicker outline around
    g.strokeStyle = '#0a0a0a';
    g.lineWidth = 2;
    g.strokeRect(7,9,16,14);

    return s;
  })();

  // flying bucket (generic "KFC-ish" without logos)
  const bucketSprite = (() => {
    const s = document.createElement('canvas');
    s.width = 22; s.height = 22;
    const g = s.getContext('2d');
    g.imageSmoothingEnabled = false;

    // outline
    g.fillStyle = '#0a0a0a';
    g.fillRect(5,6,12,14);

    // bucket body
    g.fillStyle = '#f7f7f7';
    g.fillRect(6,8,10,11);

    // red stripes
    g.fillStyle = '#ff3b3b';
    g.fillRect(7,9,2,9);
    g.fillRect(11,9,2,9);
    g.fillRect(15,9,1,9);

    // rim
    g.fillStyle = '#dcdcdc';
    g.fillRect(6,7,10,2);

    // wings (tiny)
    g.fillStyle = '#ffffff';
    g.fillRect(2,10,3,3);
    g.fillRect(17,10,3,3);

    return s;
  })();

  function render3D(){
    const w = buf.width;
    const h = buf.height;

    const mood = STAGES[stage].mood;
    const t = Math.min(1, mood/6);

    // SKY
    const sky = bctx.createLinearGradient(0,0,0,h*0.55);
    sky.addColorStop(0, PALETTE.skyTop);
    sky.addColorStop(1, PALETTE.skyBot);
    bctx.fillStyle = sky;
    bctx.fillRect(0,0,w,h);

    // clouds (more "realistic" but still pixel)
    bctx.globalAlpha = 0.85;
    for (let i=0;i<6;i++){
      const baseX = ((i*85 + (performance.now()*0.012)) % (w+160)) - 80;
      const baseY = 16 + i*7;

      // shadow
      bctx.fillStyle = 'rgba(0,0,0,0.12)';
      bctx.fillRect(baseX+8,  baseY+8, 30, 10);
      bctx.fillRect(baseX+28, baseY+4, 34, 12);
      bctx.fillRect(baseX+52, baseY+8, 36, 10);

      // body
      bctx.fillStyle = 'rgba(255,255,255,0.82)';
      bctx.fillRect(baseX,    baseY+6, 34, 12);
      bctx.fillRect(baseX+20, baseY+2, 40, 16);
      bctx.fillRect(baseX+50, baseY+6, 44, 12);

      // highlight
      bctx.fillStyle = 'rgba(255,255,255,0.35)';
      bctx.fillRect(baseX+24, baseY+4, 18, 6);
      bctx.fillRect(baseX+56, baseY+8, 16, 5);
    }
    bctx.globalAlpha = 1;

    // GRASS
    const floor = bctx.createLinearGradient(0,h*0.55,0,h);
    floor.addColorStop(0, PALETTE.grassTop);
    floor.addColorStop(1, PALETTE.grassBot);
    bctx.fillStyle = floor;
    bctx.fillRect(0, (h*0.55)|0, w, h);

    // grass strokes (painted look)
    bctx.globalAlpha = 0.18;
    for (let i=0;i<90;i++){
      const gx = (Math.random()*w)|0;
      const gy = ((h*0.60) + Math.random()*(h*0.38))|0;
      const len = 2 + (Math.random()*4)|0;
      bctx.fillStyle = (Math.random() < 0.5) ? 'rgba(0,0,0,0.20)' : 'rgba(255,255,255,0.10)';
      bctx.fillRect(gx, gy, 1, len);
    }
    bctx.globalAlpha = 1;

    // painted clumps
    bctx.globalAlpha = 0.10;
    bctx.fillStyle = '#067a3a';
    for (let i=0;i<18;i++){
      const gx = (Math.random()*w)|0;
      const gy = ((h*0.62) + Math.random()*(h*0.34))|0;
      bctx.fillRect(gx, gy, 10, 3);
      bctx.fillRect(gx+3, gy-2, 7, 2);
    }
    bctx.globalAlpha = 1;

    // WALLS (watermelon)
    const zBuffer = new Float32Array(w);
    const graffitiCols = [];

    for (let x=0;x<w;x++){
      const camX = (2*x/w - 1);
      const ra = player.a + camX * (player.fov/2);
      const hit = castRay(player.x, player.y, ra);

      // fisheye fix
      const dist = hit.dist * Math.cos(ra - player.a);
      zBuffer[x] = dist;

      const wallH = Math.min(h, (h / (dist)) * 0.95);
      const y0 = ((h - wallH) / 2) | 0;

      // shade by distance
      const shade = Math.max(0, Math.min(1, 1 - dist/11));
      const sideDark = hit.side ? 0.86 : 1.0;
      const k = shade * sideDark;

      // watermelon pattern: rind near bottom, flesh middle
      const rindBand = (y0 + wallH - 4) | 0;

      // flesh
      bctx.fillStyle = (k > 0.55) ? PALETTE.wmFlesh1 : PALETTE.wmFlesh2;
      bctx.fillRect(x, y0, 1, wallH|0);

      // rind stripe at bottom
      bctx.fillStyle = (k > 0.55) ? PALETTE.wmRind1 : PALETTE.wmRind2;
      bctx.fillRect(x, rindBand, 1, Math.max(2, (wallH*0.12)|0));

      // seeds sprinkled
      if (((x + (dist*13)|0) % 11) === 0 && wallH > 18){
        bctx.fillStyle = 'rgba(0,0,0,0.55)';
        bctx.fillRect(x, y0 + ((wallH*0.40)|0), 1, 2);
      }

      // chunky outline vibe
      if (x % 2 === 0){
        bctx.fillStyle = 'rgba(0,0,0,0.18)';
        bctx.fillRect(x, y0, 1, wallH|0);
      }

      // collect graffiti columns for tile id 3
      if (hit.tile === 3){
        graffitiCols.push({x, y0, wallH});
      }
    }

    // Graffiti: "××–×œ ×˜×•×‘ ×‘×™×’×™" across segments
    if (graffitiCols.length){
      // group contiguous columns
      const segs = [];
      let s = null;
      for (const c of graffitiCols){
        if (!s || c.x !== s.x1 + 1){
          if (s) segs.push(s);
          s = {x0:c.x, x1:c.x, y0:c.y0, y1:c.y0 + c.wallH, wallH:c.wallH};
        } else {
          s.x1 = c.x;
          s.y0 = Math.min(s.y0, c.y0);
          s.y1 = Math.max(s.y1, c.y0 + c.wallH);
          s.wallH = Math.max(s.wallH, c.wallH);
        }
      }
      if (s) segs.push(s);

      bctx.save();
      bctx.textAlign = 'center';
      bctx.textBaseline = 'middle';
      // pixel-ish font
      bctx.font = '10px ui-monospace, Menlo, Consolas, monospace';

      for (const sg of segs){
        const cx = ((sg.x0 + sg.x1) / 2);
        const cy = (sg.y0 + sg.y1) / 2;

        // spray shadow
        bctx.fillStyle = 'rgba(0,0,0,0.55)';
        bctx.fillText('××–×œ ×˜×•×‘ ×‘×™×’×™', cx+1, cy+1);

        // main spray
        bctx.fillStyle = 'rgba(255,255,255,0.92)';
        bctx.fillText('××–×œ ×˜×•×‘ ×‘×™×’×™', cx, cy);

        // pink spray highlight
        bctx.fillStyle = 'rgba(255,74,106,0.85)';
        bctx.fillText('××–×œ ×˜×•×‘ ×‘×™×’×™', cx, cy-1);
      }
      bctx.restore();
    }

    // SPRITES (fried chicken on the ground)
    const sprites = [];
    for (const tEnt of trees){
      if (!tEnt.alive) continue;
      const dx = tEnt.x - player.x;
      const dy = tEnt.y - player.y;
      const dist = Math.hypot(dx,dy);
      if (dist > 18) continue;

      const ang = Math.atan2(dy, dx) - player.a;
      let a = ang;
      while (a < -Math.PI) a += Math.PI*2;
      while (a >  Math.PI) a -= Math.PI*2;

      if (Math.abs(a) > player.fov*0.75) continue;
      sprites.push({dist, a, kind:'chicken', ent:tEnt});
    }

    // flying buckets
    for (const b of flyers){
      const dx = b.x - player.x;
      const dy = b.y - player.y;
      const dist = Math.hypot(dx,dy);
      if (dist > 26) continue;

      const ang = Math.atan2(dy, dx) - player.a;
      let a = ang;
      while (a < -Math.PI) a += Math.PI*2;
      while (a >  Math.PI) a -= Math.PI*2;
      if (Math.abs(a) > player.fov*0.85) continue;
      sprites.push({dist, a, kind:'bucket', ent:b});
    }

    sprites.sort((a,b)=>b.dist - a.dist);

    for (const s of sprites){
      const dist = Math.max(0.2, s.dist);
      const size = Math.min(h*0.9, (h / dist) * (s.kind==='bucket' ? 0.55 : 0.819));
      const sx = ((w/2) * (1 + (s.a / (player.fov/2)))) - size/2;

      // buckets appear in the SKY; chickens near ground
      const sy = (s.kind==='bucket')
        ? (h*0.20 - size*0.15)
        : (h/2) - size*0.12;

      const x0 = sx|0;
      const x1 = (sx + size)|0;

      // occlusion with zBuffer (simple)
      for (let x = x0; x < x1; x++){
        if (x < 0 || x >= w) continue;
        if (zBuffer[x] > dist - 0.05){
          if (s.kind==='bucket') bctx.drawImage(bucketSprite, sx, sy, size, size);
          else bctx.drawImage(chickenSprite, sx, sy, size, size);
          break;
        }
      }

      // crosshair hint when close to a chicken
      if (s.kind==='chicken' && dist < 1.6){
        bctx.fillStyle = 'rgba(0,0,0,0.28)';
        bctx.fillRect((w/2)|0, (h*0.72)|0, 2, 2);
        bctx.fillStyle = 'rgba(126,226,184,0.30)';
        bctx.fillRect(((w/2)+1)|0, ((h*0.72)+1)|0, 1, 1);
      }
    }

    // darkness ramp for stages 4-6 (index 3-5), peak at stage 6
    const darkLevel = (stage >= 3 && stage <= 5)
      ? (0.22 + (stage-3) * 0.20)   // stage4~0.22, stage5~0.42, stage6~0.62
      : 0;

    // eye hints only when it starts getting dark
    if (stage >= 3){
      const chance = 0.010 + Math.min(0.03, darkLevel*0.05);
      if (Math.random() < chance){
        const ex = (Math.random()*w)|0;
        const ey = (Math.random()*(h*0.45))|0;
        bctx.fillStyle = 'rgba(255,77,109,0.85)';
        bctx.fillRect(ex, ey, 2, 1);
        bctx.fillRect(ex+3, ey, 2, 1);
      }
    }

    // dark overlay
    if (darkLevel > 0){
      bctx.fillStyle = `rgba(0,0,0,${darkLevel})`;
      bctx.fillRect(0,0,w,h);
    }

    // light fog
    bctx.fillStyle = PALETTE.fog;
    bctx.fillRect(0,0,w,h);

    // flicker
    if (flicker > 0){
      bctx.fillStyle = `rgba(255,255,255,${Math.min(0.12, flicker*0.55)})`;
      bctx.fillRect(0,0,w,h);
    }
  }

  function blit(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    // scale buffer to full canvas
    ctx.drawImage(buf, 0,0, buf.width, buf.height, 0,0, canvas.width, canvas.height);
  }

  // --- Loop ---
  let last = 0;
  function loop(ts){
    const dt = Math.min(0.05, (ts - last)/1000 || 0);
    last = ts;

    if (running){
      move(dt);
      flicker = Math.max(0, flicker - dt);

      // ambience ramps up each level until stage 6 (index 5)
      const lvl = stageIntensity();

      // heartbeat (always, gets stronger)
      heartT -= dt;
      if (heartT <= 0){
        heartT = heartbeat(lvl);
      }

      // breathing (more noticeable on dark stages)
      if (stage >= 3){
        breathT -= dt;
        if (breathT <= 0){
          breathT = 1.6 - lvl*0.7;
          softBreath(lvl);
        }
      }

      // footsteps when moving
      const moving = keys.has('arrowup') || keys.has('arrowdown') || keys.has('arrowleft') || keys.has('arrowright');
      if (moving){
        stepT -= dt;
        if (stepT <= 0){
          stepT = 0.42 - lvl*0.18;
          softStep(lvl);
        }
      } else {
        stepT = Math.min(stepT, 0.12);
      }

      // spawn fast flying buckets every so often
      flySpawn -= dt;
      if (flySpawn <= 0){
        flySpawn = 0.9 + Math.random()*1.6; // "every so often"
        const side = Math.random() < 0.5 ? -1 : 1;
        const ang = player.a + (side * (0.9 + Math.random()*0.4));
        const px = player.x + Math.cos(ang) * (14 + Math.random()*8);
        const py = player.y + Math.sin(ang) * (14 + Math.random()*8);
        const vx = Math.cos(player.a) * (10 + Math.random()*8) + (Math.random()*2-1);
        const vy = Math.sin(player.a) * (10 + Math.random()*8) + (Math.random()*2-1);
        flyers.push({x:px, y:py, vx, vy, life: 1.2 + Math.random()*0.8});
      }

      // update flyers
      for (let i=flyers.length-1;i>=0;i--){
        const b = flyers[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dt;
        if (b.life <= 0) flyers.splice(i,1);
      }

      render3D();
      blit();
    }

    requestAnimationFrame(loop);
  }

  // --- UI wiring ---
  btnStart.onclick = () => {
    overlay.classList.add('hidden');
    running = true;
    ensureAudio();
  };

    btnRestart.onclick = () => location.reload();

  btnMute.onclick = () => {
    muted = !muted;
    btnMute.textContent = muted ? '×¡××•× ×“: OFF' : '×¡××•× ×“: ON';
    if (muted && audioCtx){ try{audioCtx.suspend();}catch{} }
    if (!muted){ ensureAudio(); beep({freq:520, dur:0.06, gain:0.02, type:'sine'}); }
  };

  // init
  resize();
  setStage(0);
  woodLbl.textContent = '0';
  goalLbl.textContent = String(STAGES[0].goal);
  needLbl.textContent = '0';
  prog.style.width = '0%';

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
